// swift-format-ignore-file
// Generated by swift-openapi-generator, do not modify.
@_spi(Generated) import OpenAPIRuntime
#if os(Linux)
@preconcurrency import struct Foundation.URL
@preconcurrency import struct Foundation.Data
@preconcurrency import struct Foundation.Date
#else
import struct Foundation.URL
import struct Foundation.Data
import struct Foundation.Date
#endif
import HTTPTypes
internal struct Client: APIProtocol {
    /// The underlying HTTP client.
    private let client: UniversalClient
    /// Creates a new client.
    /// - Parameters:
    ///   - serverURL: The server URL that the client connects to. Any server
    ///   URLs defined in the OpenAPI document are available as static methods
    ///   on the ``Servers`` type.
    ///   - configuration: A set of configuration values for the client.
    ///   - transport: A transport that performs HTTP operations.
    ///   - middlewares: A list of middlewares to call before the transport.
    internal init(
        serverURL: Foundation.URL,
        configuration: Configuration = .init(),
        transport: any ClientTransport,
        middlewares: [any ClientMiddleware] = []
    ) {
        self.client = .init(
            serverURL: serverURL,
            configuration: configuration,
            transport: transport,
            middlewares: middlewares
        )
    }
    private var converter: Converter {
        client.converter
    }
    /// - Remark: HTTP `POST /users`.
    /// - Remark: Generated from `#/paths//users/post(postUsers)`.
    internal func postUsers(_ input: Operations.PostUsers.Input) async throws -> Operations.PostUsers.Output {
        try await client.send(
            input: input,
            forOperation: Operations.PostUsers.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/users",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "anonymous-user-id",
                    value: input.headers.anonymousUserId
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let headers: Operations.PostUsers.Output.Created.Headers = .init(authorization: try converter.getRequiredHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "authorization",
                        as: Swift.String.self
                    ))
                    return .created(.init(headers: headers))
                case 401:
                    let headers: Operations.PostUsers.Output.Unauthorized.Headers = .init(contentType: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Content-Type",
                        as: Operations.PostUsers.Output.Unauthorized.Headers.ContentTypePayload.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.PostUsers.Output.Unauthorized.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.PostUsers.Output.Unauthorized.Body.JsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unauthorized(.init(
                        headers: headers,
                        body: body
                    ))
                case 403:
                    let headers: Operations.PostUsers.Output.Forbidden.Headers = .init(contentType: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Content-Type",
                        as: Operations.PostUsers.Output.Forbidden.Headers.ContentTypePayload.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.PostUsers.Output.Forbidden.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.PostUsers.Output.Forbidden.Body.JsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .forbidden(.init(
                        headers: headers,
                        body: body
                    ))
                case 404:
                    let headers: Operations.PostUsers.Output.NotFound.Headers = .init(contentType: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Content-Type",
                        as: Operations.PostUsers.Output.NotFound.Headers.ContentTypePayload.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.PostUsers.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.PostUsers.Output.NotFound.Body.JsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(
                        headers: headers,
                        body: body
                    ))
                case 422:
                    let headers: Operations.PostUsers.Output.UnprocessableContent.Headers = .init(contentType: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Content-Type",
                        as: Operations.PostUsers.Output.UnprocessableContent.Headers.ContentTypePayload.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.PostUsers.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.PostUsers.Output.UnprocessableContent.Body.JsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(
                        headers: headers,
                        body: body
                    ))
                case 429:
                    let headers: Operations.PostUsers.Output.TooManyRequests.Headers = .init(contentType: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Content-Type",
                        as: Operations.PostUsers.Output.TooManyRequests.Headers.ContentTypePayload.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.PostUsers.Output.TooManyRequests.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.PostUsers.Output.TooManyRequests.Body.JsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .tooManyRequests(.init(
                        headers: headers,
                        body: body
                    ))
                case 500:
                    let headers: Operations.PostUsers.Output.InternalServerError.Headers = .init(contentType: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Content-Type",
                        as: Operations.PostUsers.Output.InternalServerError.Headers.ContentTypePayload.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.PostUsers.Output.InternalServerError.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.PostUsers.Output.InternalServerError.Body.JsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .internalServerError(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `PUT /users`.
    /// - Remark: Generated from `#/paths//users/put(putUsers)`.
    internal func putUsers(_ input: Operations.PutUsers.Input) async throws -> Operations.PutUsers.Output {
        try await client.send(
            input: input,
            forOperation: Operations.PutUsers.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/users",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .put
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 204:
                    return .noContent(.init())
                case 401:
                    let headers: Operations.PutUsers.Output.Unauthorized.Headers = .init(contentType: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Content-Type",
                        as: Operations.PutUsers.Output.Unauthorized.Headers.ContentTypePayload.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.PutUsers.Output.Unauthorized.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.PutUsers.Output.Unauthorized.Body.JsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unauthorized(.init(
                        headers: headers,
                        body: body
                    ))
                case 403:
                    let headers: Operations.PutUsers.Output.Forbidden.Headers = .init(contentType: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Content-Type",
                        as: Operations.PutUsers.Output.Forbidden.Headers.ContentTypePayload.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.PutUsers.Output.Forbidden.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.PutUsers.Output.Forbidden.Body.JsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .forbidden(.init(
                        headers: headers,
                        body: body
                    ))
                case 404:
                    let headers: Operations.PutUsers.Output.NotFound.Headers = .init(contentType: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Content-Type",
                        as: Operations.PutUsers.Output.NotFound.Headers.ContentTypePayload.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.PutUsers.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.PutUsers.Output.NotFound.Body.JsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(
                        headers: headers,
                        body: body
                    ))
                case 409:
                    let headers: Operations.PutUsers.Output.Conflict.Headers = .init(contentType: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Content-Type",
                        as: Operations.PutUsers.Output.Conflict.Headers.ContentTypePayload.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.PutUsers.Output.Conflict.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.PutUsers.Output.Conflict.Body.JsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .conflict(.init(
                        headers: headers,
                        body: body
                    ))
                case 422:
                    let headers: Operations.PutUsers.Output.UnprocessableContent.Headers = .init(contentType: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Content-Type",
                        as: Operations.PutUsers.Output.UnprocessableContent.Headers.ContentTypePayload.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.PutUsers.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.PutUsers.Output.UnprocessableContent.Body.JsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(
                        headers: headers,
                        body: body
                    ))
                case 500:
                    let headers: Operations.PutUsers.Output.InternalServerError.Headers = .init(contentType: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Content-Type",
                        as: Operations.PutUsers.Output.InternalServerError.Headers.ContentTypePayload.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.PutUsers.Output.InternalServerError.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.PutUsers.Output.InternalServerError.Body.JsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .internalServerError(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `DELETE /users`.
    /// - Remark: Generated from `#/paths//users/delete(deleteUsers)`.
    internal func deleteUsers(_ input: Operations.DeleteUsers.Input) async throws -> Operations.DeleteUsers.Output {
        try await client.send(
            input: input,
            forOperation: Operations.DeleteUsers.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/users",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 204:
                    return .noContent(.init())
                case 401:
                    let headers: Operations.DeleteUsers.Output.Unauthorized.Headers = .init(contentType: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Content-Type",
                        as: Operations.DeleteUsers.Output.Unauthorized.Headers.ContentTypePayload.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.DeleteUsers.Output.Unauthorized.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.DeleteUsers.Output.Unauthorized.Body.JsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unauthorized(.init(
                        headers: headers,
                        body: body
                    ))
                case 403:
                    let headers: Operations.DeleteUsers.Output.Forbidden.Headers = .init(contentType: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Content-Type",
                        as: Operations.DeleteUsers.Output.Forbidden.Headers.ContentTypePayload.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.DeleteUsers.Output.Forbidden.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.DeleteUsers.Output.Forbidden.Body.JsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .forbidden(.init(
                        headers: headers,
                        body: body
                    ))
                case 404:
                    let headers: Operations.DeleteUsers.Output.NotFound.Headers = .init(contentType: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Content-Type",
                        as: Operations.DeleteUsers.Output.NotFound.Headers.ContentTypePayload.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.DeleteUsers.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.DeleteUsers.Output.NotFound.Body.JsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(
                        headers: headers,
                        body: body
                    ))
                case 422:
                    let headers: Operations.DeleteUsers.Output.UnprocessableContent.Headers = .init(contentType: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Content-Type",
                        as: Operations.DeleteUsers.Output.UnprocessableContent.Headers.ContentTypePayload.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.DeleteUsers.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.DeleteUsers.Output.UnprocessableContent.Body.JsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(
                        headers: headers,
                        body: body
                    ))
                case 500:
                    let headers: Operations.DeleteUsers.Output.InternalServerError.Headers = .init(contentType: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Content-Type",
                        as: Operations.DeleteUsers.Output.InternalServerError.Headers.ContentTypePayload.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.DeleteUsers.Output.InternalServerError.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.DeleteUsers.Output.InternalServerError.Body.JsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .internalServerError(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /linked-accounts`.
    /// - Remark: Generated from `#/paths//linked-accounts/get(getLinkedAccounts)`.
    internal func getLinkedAccounts(_ input: Operations.GetLinkedAccounts.Input) async throws -> Operations.GetLinkedAccounts.Output {
        try await client.send(
            input: input,
            forOperation: Operations.GetLinkedAccounts.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/linked-accounts",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.GetLinkedAccounts.Output.Ok.Headers = .init(
                        contentType: try converter.getOptionalHeaderFieldAsURI(
                            in: response.headerFields,
                            name: "Content-Type",
                            as: Operations.GetLinkedAccounts.Output.Ok.Headers.ContentTypePayload.self
                        ),
                        contentEncoding: try converter.getOptionalHeaderFieldAsURI(
                            in: response.headerFields,
                            name: "Content-Encoding",
                            as: Operations.GetLinkedAccounts.Output.Ok.Headers.ContentEncodingPayload.self
                        )
                    )
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.GetLinkedAccounts.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.LinkedAccount].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                case 401:
                    let headers: Operations.GetLinkedAccounts.Output.Unauthorized.Headers = .init(contentType: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Content-Type",
                        as: Operations.GetLinkedAccounts.Output.Unauthorized.Headers.ContentTypePayload.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.GetLinkedAccounts.Output.Unauthorized.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.GetLinkedAccounts.Output.Unauthorized.Body.JsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unauthorized(.init(
                        headers: headers,
                        body: body
                    ))
                case 404:
                    let headers: Operations.GetLinkedAccounts.Output.NotFound.Headers = .init(contentType: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Content-Type",
                        as: Operations.GetLinkedAccounts.Output.NotFound.Headers.ContentTypePayload.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.GetLinkedAccounts.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.GetLinkedAccounts.Output.NotFound.Body.JsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(
                        headers: headers,
                        body: body
                    ))
                case 422:
                    let headers: Operations.GetLinkedAccounts.Output.UnprocessableContent.Headers = .init(contentType: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Content-Type",
                        as: Operations.GetLinkedAccounts.Output.UnprocessableContent.Headers.ContentTypePayload.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.GetLinkedAccounts.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.GetLinkedAccounts.Output.UnprocessableContent.Body.JsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(
                        headers: headers,
                        body: body
                    ))
                case 500:
                    let headers: Operations.GetLinkedAccounts.Output.InternalServerError.Headers = .init(contentType: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Content-Type",
                        as: Operations.GetLinkedAccounts.Output.InternalServerError.Headers.ContentTypePayload.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.GetLinkedAccounts.Output.InternalServerError.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.GetLinkedAccounts.Output.InternalServerError.Body.JsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .internalServerError(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /linked-accounts`.
    /// - Remark: Generated from `#/paths//linked-accounts/post(postLinkedAccounts)`.
    internal func postLinkedAccounts(_ input: Operations.PostLinkedAccounts.Input) async throws -> Operations.PostLinkedAccounts.Output {
        try await client.send(
            input: input,
            forOperation: Operations.PostLinkedAccounts.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/linked-accounts",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let headers: Operations.PostLinkedAccounts.Output.Created.Headers = .init(contentType: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Content-Type",
                        as: Operations.PostLinkedAccounts.Output.Created.Headers.ContentTypePayload.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.PostLinkedAccounts.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.LinkedAccount.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(
                        headers: headers,
                        body: body
                    ))
                case 401:
                    let headers: Operations.PostLinkedAccounts.Output.Unauthorized.Headers = .init(contentType: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Content-Type",
                        as: Operations.PostLinkedAccounts.Output.Unauthorized.Headers.ContentTypePayload.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.PostLinkedAccounts.Output.Unauthorized.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.PostLinkedAccounts.Output.Unauthorized.Body.JsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unauthorized(.init(
                        headers: headers,
                        body: body
                    ))
                case 404:
                    let headers: Operations.PostLinkedAccounts.Output.NotFound.Headers = .init(contentType: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Content-Type",
                        as: Operations.PostLinkedAccounts.Output.NotFound.Headers.ContentTypePayload.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.PostLinkedAccounts.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.PostLinkedAccounts.Output.NotFound.Body.JsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(
                        headers: headers,
                        body: body
                    ))
                case 409:
                    let headers: Operations.PostLinkedAccounts.Output.Conflict.Headers = .init(contentType: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Content-Type",
                        as: Operations.PostLinkedAccounts.Output.Conflict.Headers.ContentTypePayload.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.PostLinkedAccounts.Output.Conflict.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.PostLinkedAccounts.Output.Conflict.Body.JsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .conflict(.init(
                        headers: headers,
                        body: body
                    ))
                case 422:
                    let headers: Operations.PostLinkedAccounts.Output.UnprocessableContent.Headers = .init(contentType: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Content-Type",
                        as: Operations.PostLinkedAccounts.Output.UnprocessableContent.Headers.ContentTypePayload.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.PostLinkedAccounts.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.PostLinkedAccounts.Output.UnprocessableContent.Body.JsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(
                        headers: headers,
                        body: body
                    ))
                case 428:
                    let headers: Operations.PostLinkedAccounts.Output.PreconditionRequired.Headers = .init(contentType: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Content-Type",
                        as: Operations.PostLinkedAccounts.Output.PreconditionRequired.Headers.ContentTypePayload.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.PostLinkedAccounts.Output.PreconditionRequired.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.MFARequest.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .preconditionRequired(.init(
                        headers: headers,
                        body: body
                    ))
                case 500:
                    let headers: Operations.PostLinkedAccounts.Output.InternalServerError.Headers = .init(contentType: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Content-Type",
                        as: Operations.PostLinkedAccounts.Output.InternalServerError.Headers.ContentTypePayload.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.PostLinkedAccounts.Output.InternalServerError.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.PostLinkedAccounts.Output.InternalServerError.Body.JsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .internalServerError(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `DELETE /linked-accounts/{linkedAccountID}`.
    /// - Remark: Generated from `#/paths//linked-accounts/{linkedAccountID}/delete(deleteLinkedAccount)`.
    internal func deleteLinkedAccount(_ input: Operations.DeleteLinkedAccount.Input) async throws -> Operations.DeleteLinkedAccount.Output {
        try await client.send(
            input: input,
            forOperation: Operations.DeleteLinkedAccount.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/linked-accounts/{}",
                    parameters: [
                        input.path.linkedAccountID
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 204:
                    let headers: Operations.DeleteLinkedAccount.Output.NoContent.Headers = .init(
                        contentType: try converter.getOptionalHeaderFieldAsURI(
                            in: response.headerFields,
                            name: "Content-Type",
                            as: Operations.DeleteLinkedAccount.Output.NoContent.Headers.ContentTypePayload.self
                        ),
                        contentEncoding: try converter.getOptionalHeaderFieldAsURI(
                            in: response.headerFields,
                            name: "Content-Encoding",
                            as: Operations.DeleteLinkedAccount.Output.NoContent.Headers.ContentEncodingPayload.self
                        )
                    )
                    return .noContent(.init(headers: headers))
                case 401:
                    let headers: Operations.DeleteLinkedAccount.Output.Unauthorized.Headers = .init(contentType: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Content-Type",
                        as: Operations.DeleteLinkedAccount.Output.Unauthorized.Headers.ContentTypePayload.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.DeleteLinkedAccount.Output.Unauthorized.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.DeleteLinkedAccount.Output.Unauthorized.Body.JsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unauthorized(.init(
                        headers: headers,
                        body: body
                    ))
                case 404:
                    let headers: Operations.DeleteLinkedAccount.Output.NotFound.Headers = .init(contentType: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Content-Type",
                        as: Operations.DeleteLinkedAccount.Output.NotFound.Headers.ContentTypePayload.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.DeleteLinkedAccount.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.DeleteLinkedAccount.Output.NotFound.Body.JsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(
                        headers: headers,
                        body: body
                    ))
                case 409:
                    let headers: Operations.DeleteLinkedAccount.Output.Conflict.Headers = .init(contentType: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Content-Type",
                        as: Operations.DeleteLinkedAccount.Output.Conflict.Headers.ContentTypePayload.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.DeleteLinkedAccount.Output.Conflict.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.DeleteLinkedAccount.Output.Conflict.Body.JsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .conflict(.init(
                        headers: headers,
                        body: body
                    ))
                case 422:
                    let headers: Operations.DeleteLinkedAccount.Output.UnprocessableContent.Headers = .init(contentType: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Content-Type",
                        as: Operations.DeleteLinkedAccount.Output.UnprocessableContent.Headers.ContentTypePayload.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.DeleteLinkedAccount.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.DeleteLinkedAccount.Output.UnprocessableContent.Body.JsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(
                        headers: headers,
                        body: body
                    ))
                case 500:
                    let headers: Operations.DeleteLinkedAccount.Output.InternalServerError.Headers = .init(contentType: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Content-Type",
                        as: Operations.DeleteLinkedAccount.Output.InternalServerError.Headers.ContentTypePayload.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.DeleteLinkedAccount.Output.InternalServerError.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.DeleteLinkedAccount.Output.InternalServerError.Body.JsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .internalServerError(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /linked-accounts/fiat-holding-accounts`.
    /// - Remark: Generated from `#/paths//linked-accounts/fiat-holding-accounts/get(getLinkedAccountsFiatHoldingAccounts)`.
    internal func getLinkedAccountsFiatHoldingAccounts(_ input: Operations.GetLinkedAccountsFiatHoldingAccounts.Input) async throws -> Operations.GetLinkedAccountsFiatHoldingAccounts.Output {
        try await client.send(
            input: input,
            forOperation: Operations.GetLinkedAccountsFiatHoldingAccounts.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/linked-accounts/fiat-holding-accounts",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "linkedAccountIDs",
                    value: input.query.linkedAccountIDs
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.GetLinkedAccountsFiatHoldingAccounts.Output.Ok.Headers = .init(
                        contentType: try converter.getOptionalHeaderFieldAsURI(
                            in: response.headerFields,
                            name: "Content-Type",
                            as: Operations.GetLinkedAccountsFiatHoldingAccounts.Output.Ok.Headers.ContentTypePayload.self
                        ),
                        contentEncoding: try converter.getOptionalHeaderFieldAsURI(
                            in: response.headerFields,
                            name: "Content-Encoding",
                            as: Operations.GetLinkedAccountsFiatHoldingAccounts.Output.Ok.Headers.ContentEncodingPayload.self
                        )
                    )
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.GetLinkedAccountsFiatHoldingAccounts.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.PrimaryFiatHoldingAccount].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                case 401:
                    let headers: Operations.GetLinkedAccountsFiatHoldingAccounts.Output.Unauthorized.Headers = .init(contentType: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Content-Type",
                        as: Operations.GetLinkedAccountsFiatHoldingAccounts.Output.Unauthorized.Headers.ContentTypePayload.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.GetLinkedAccountsFiatHoldingAccounts.Output.Unauthorized.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.GetLinkedAccountsFiatHoldingAccounts.Output.Unauthorized.Body.JsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unauthorized(.init(
                        headers: headers,
                        body: body
                    ))
                case 404:
                    let headers: Operations.GetLinkedAccountsFiatHoldingAccounts.Output.NotFound.Headers = .init(contentType: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Content-Type",
                        as: Operations.GetLinkedAccountsFiatHoldingAccounts.Output.NotFound.Headers.ContentTypePayload.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.GetLinkedAccountsFiatHoldingAccounts.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.GetLinkedAccountsFiatHoldingAccounts.Output.NotFound.Body.JsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(
                        headers: headers,
                        body: body
                    ))
                case 422:
                    let headers: Operations.GetLinkedAccountsFiatHoldingAccounts.Output.UnprocessableContent.Headers = .init(contentType: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Content-Type",
                        as: Operations.GetLinkedAccountsFiatHoldingAccounts.Output.UnprocessableContent.Headers.ContentTypePayload.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.GetLinkedAccountsFiatHoldingAccounts.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.GetLinkedAccountsFiatHoldingAccounts.Output.UnprocessableContent.Body.JsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(
                        headers: headers,
                        body: body
                    ))
                case 500:
                    let headers: Operations.GetLinkedAccountsFiatHoldingAccounts.Output.InternalServerError.Headers = .init(contentType: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Content-Type",
                        as: Operations.GetLinkedAccountsFiatHoldingAccounts.Output.InternalServerError.Headers.ContentTypePayload.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.GetLinkedAccountsFiatHoldingAccounts.Output.InternalServerError.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.GetLinkedAccountsFiatHoldingAccounts.Output.InternalServerError.Body.JsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .internalServerError(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /linked-accounts/activity`.
    /// - Remark: Generated from `#/paths//linked-accounts/activity/get(getLinkedAccountsActivity)`.
    internal func getLinkedAccountsActivity(_ input: Operations.GetLinkedAccountsActivity.Input) async throws -> Operations.GetLinkedAccountsActivity.Output {
        try await client.send(
            input: input,
            forOperation: Operations.GetLinkedAccountsActivity.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/linked-accounts/activity",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "linkedAccountIDs",
                    value: input.query.linkedAccountIDs
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "assetKind",
                    value: input.query.assetKind
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "span",
                    value: input.query.span
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let headers: Operations.GetLinkedAccountsActivity.Output.Ok.Headers = .init(
                        contentType: try converter.getOptionalHeaderFieldAsURI(
                            in: response.headerFields,
                            name: "Content-Type",
                            as: Operations.GetLinkedAccountsActivity.Output.Ok.Headers.ContentTypePayload.self
                        ),
                        contentEncoding: try converter.getOptionalHeaderFieldAsURI(
                            in: response.headerFields,
                            name: "Content-Encoding",
                            as: Operations.GetLinkedAccountsActivity.Output.Ok.Headers.ContentEncodingPayload.self
                        )
                    )
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.GetLinkedAccountsActivity.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.PortfolioActivityItem].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(
                        headers: headers,
                        body: body
                    ))
                case 401:
                    let headers: Operations.GetLinkedAccountsActivity.Output.Unauthorized.Headers = .init(contentType: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Content-Type",
                        as: Operations.GetLinkedAccountsActivity.Output.Unauthorized.Headers.ContentTypePayload.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.GetLinkedAccountsActivity.Output.Unauthorized.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.GetLinkedAccountsActivity.Output.Unauthorized.Body.JsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unauthorized(.init(
                        headers: headers,
                        body: body
                    ))
                case 404:
                    let headers: Operations.GetLinkedAccountsActivity.Output.NotFound.Headers = .init(contentType: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Content-Type",
                        as: Operations.GetLinkedAccountsActivity.Output.NotFound.Headers.ContentTypePayload.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.GetLinkedAccountsActivity.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.GetLinkedAccountsActivity.Output.NotFound.Body.JsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(
                        headers: headers,
                        body: body
                    ))
                case 422:
                    let headers: Operations.GetLinkedAccountsActivity.Output.UnprocessableContent.Headers = .init(contentType: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Content-Type",
                        as: Operations.GetLinkedAccountsActivity.Output.UnprocessableContent.Headers.ContentTypePayload.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.GetLinkedAccountsActivity.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.GetLinkedAccountsActivity.Output.UnprocessableContent.Body.JsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(
                        headers: headers,
                        body: body
                    ))
                case 500:
                    let headers: Operations.GetLinkedAccountsActivity.Output.InternalServerError.Headers = .init(contentType: try converter.getOptionalHeaderFieldAsURI(
                        in: response.headerFields,
                        name: "Content-Type",
                        as: Operations.GetLinkedAccountsActivity.Output.InternalServerError.Headers.ContentTypePayload.self
                    ))
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.GetLinkedAccountsActivity.Output.InternalServerError.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.GetLinkedAccountsActivity.Output.InternalServerError.Body.JsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .internalServerError(.init(
                        headers: headers,
                        body: body
                    ))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
}
