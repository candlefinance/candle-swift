// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.2.1 effective-5.10 (swiftlang-6.2.1.4.8 clang-1700.4.4.1)
// swift-module-flags: -target arm64-apple-macos10.13 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -Onone -enable-experimental-feature DebugDescriptionMacro -enable-bare-slash-regex -module-name RealModule -package-name swift_numerics
// swift-module-flags-ignorable: -no-verify-emitted-module-interface -formal-cxx-interoperability-mode=off -interface-compiler-version 6.2.1
import Swift
import _Concurrency
import _NumericsShims
import _StringProcessing
import _SwiftConcurrencyShims
public protocol AlgebraicField : Swift.SignedNumeric where Self.Magnitude : RealModule.AlgebraicField {
  static func /= (a: inout Self, b: Self)
  static func / (a: Self, b: Self) -> Self
  #if compiler(>=5.3) && $NonescapableTypes
  var reciprocal: Self? { get }
  #endif
  static func _relaxedAdd(_ a: Self, _ b: Self) -> Self
  static func _relaxedMul(_ a: Self, _ b: Self) -> Self
}
extension RealModule.AlgebraicField {
  @_transparent public static func / (a: Self, b: Self) -> Self {
    var result = a
    result /= b
    return result
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @_transparent public var reciprocal: Self? {
    @_transparent get {
    return nil
  }
  }
  #endif
  @_transparent public static func _relaxedAdd(_ a: Self, _ b: Self) -> Self {
    a + b
  }
  @_transparent public static func _relaxedMul(_ a: Self, _ b: Self) -> Self {
    a * b
  }
}
extension Swift.Numeric where Self.Magnitude : Swift.FloatingPoint {
  @inlinable @inline(__always) public func isApproximatelyEqual(to other: Self, relativeTolerance: Self.Magnitude = Magnitude.ulpOfOne.squareRoot(), norm: (Self) -> Self.Magnitude = \.magnitude) -> Swift.Bool {
    return isApproximatelyEqual(
      to: other,
      absoluteTolerance: relativeTolerance * Magnitude.leastNormalMagnitude,
      relativeTolerance: relativeTolerance,
      norm: norm
    )
  }
  @inlinable @inline(__always) public func isApproximatelyEqual(to other: Self, absoluteTolerance: Self.Magnitude, relativeTolerance: Self.Magnitude = 0) -> Swift.Bool {
    self.isApproximatelyEqual(
      to: other,
      absoluteTolerance: absoluteTolerance,
      relativeTolerance: relativeTolerance,
      norm: \.magnitude
    )
  }
}
extension Swift.AdditiveArithmetic {
  @inlinable public func isApproximatelyEqual<Magnitude>(to other: Self, absoluteTolerance: Magnitude, relativeTolerance: Magnitude = 0, norm: (Self) -> Magnitude) -> Swift.Bool where Magnitude : Swift.FloatingPoint {
    assert(
      absoluteTolerance >= 0 && absoluteTolerance.isFinite,
      "absoluteTolerance should be non-negative and finite, " +
      "but is \(absoluteTolerance)."
    )
    assert(
      relativeTolerance >= 0 && relativeTolerance <= 1,
      "relativeTolerance should be non-negative and <= 1, " +
      "but is \(relativeTolerance)."
    )
    if self == other { return true }
    let delta = norm(self - other)
    let scale = max(norm(self), norm(other))
    let bound = max(absoluteTolerance, scale*relativeTolerance)
    return delta.isFinite && delta <= bound
  }
}
public enum Augmented {
}
extension RealModule.Augmented {
  @_transparent public static func product<T>(_ a: T, _ b: T) -> (head: T, tail: T) where T : Swift.FloatingPoint {
    let head = a*b
     
     
     
    let tail = (-head).addingProduct(a, b)
    return (head, tail)
  }
  @_transparent public static func sum<T>(large a: T, small b: T) -> (head: T, tail: T) where T : Swift.FloatingPoint {
     
     
     
    guard T.radix == 2 else { return sum(a, b) }
     
    let head = a + b
    let tail = a - head + b
    return (head, tail)
  }
  @_transparent public static func sum<T>(_ a: T, _ b: T) -> (head: T, tail: T) where T : Swift.FloatingPoint {
    let head = a + b
    let x = head - b
    let y = head - x
    let tail = (a - x) + (b - y)
    return (head, tail)
  }
}
extension Swift.Double : RealModule.Real {
  @_transparent public static func cos(_ x: Swift.Double) -> Swift.Double {
    libm_cos(x)
  }
  @_transparent public static func sin(_ x: Swift.Double) -> Swift.Double {
    libm_sin(x)
  }
  @_transparent public static func tan(_ x: Swift.Double) -> Swift.Double {
    libm_tan(x)
  }
  @_transparent public static func acos(_ x: Swift.Double) -> Swift.Double {
    libm_acos(x)
  }
  @_transparent public static func asin(_ x: Swift.Double) -> Swift.Double {
    libm_asin(x)
  }
  @_transparent public static func atan(_ x: Swift.Double) -> Swift.Double {
    libm_atan(x)
  }
  @_transparent public static func cosh(_ x: Swift.Double) -> Swift.Double {
    libm_cosh(x)
  }
  @_transparent public static func sinh(_ x: Swift.Double) -> Swift.Double {
    libm_sinh(x)
  }
  @_transparent public static func tanh(_ x: Swift.Double) -> Swift.Double {
    libm_tanh(x)
  }
  @_transparent public static func acosh(_ x: Swift.Double) -> Swift.Double {
    libm_acosh(x)
  }
  @_transparent public static func asinh(_ x: Swift.Double) -> Swift.Double {
    libm_asinh(x)
  }
  @_transparent public static func atanh(_ x: Swift.Double) -> Swift.Double {
    libm_atanh(x)
  }
  @_transparent public static func exp(_ x: Swift.Double) -> Swift.Double {
    libm_exp(x)
  }
  @_transparent public static func expMinusOne(_ x: Swift.Double) -> Swift.Double {
    libm_expm1(x)
  }
  @_transparent public static func log(_ x: Swift.Double) -> Swift.Double {
    libm_log(x)
  }
  @_transparent public static func log(onePlus x: Swift.Double) -> Swift.Double {
    libm_log1p(x)
  }
  @_transparent public static func erf(_ x: Swift.Double) -> Swift.Double {
    libm_erf(x)
  }
  @_transparent public static func erfc(_ x: Swift.Double) -> Swift.Double {
    libm_erfc(x)
  }
  @_transparent public static func exp2(_ x: Swift.Double) -> Swift.Double {
    libm_exp2(x)
  }
  @_transparent public static func exp10(_ x: Swift.Double) -> Swift.Double {
    libm_exp10(x)
  }
  @_transparent public static func hypot(_ x: Swift.Double, _ y: Swift.Double) -> Swift.Double {
    libm_hypot(x, y)
  }
  @_transparent public static func gamma(_ x: Swift.Double) -> Swift.Double {
    libm_tgamma(x)
  }
  @_transparent public static func log2(_ x: Swift.Double) -> Swift.Double {
    libm_log2(x)
  }
  @_transparent public static func log10(_ x: Swift.Double) -> Swift.Double {
    libm_log10(x)
  }
  @_transparent public static func pow(_ x: Swift.Double, _ y: Swift.Double) -> Swift.Double {
    guard x >= 0 else { return .nan }
    if x == 0 && y == 0 { return .nan }
    return libm_pow(x, y)
  }
  @_transparent public static func pow(_ x: Swift.Double, _ n: Swift.Int) -> Swift.Double {
     
     
    if let y = Double(exactly: n) { return libm_pow(x, y) }
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
    let mask = Int(truncatingIfNeeded: UInt32.max)
    let round = n < 0 ? mask : 0
     
     
     
     
     
    let high = (n &+ round) & ~mask
    let low = n &- high
    return libm_pow(x, Double(low)) * libm_pow(x, Double(high))
  }
  @_transparent public static func root(_ x: Swift.Double, _ n: Swift.Int) -> Swift.Double {
    guard x >= 0 || n % 2 != 0 else { return .nan }
     
     
    if n == 3 { return libm_cbrt(x) }
     
     
    return Double(signOf: x, magnitudeOf: libm_pow(x.magnitude, 1/Double(n)))
  }
  @_transparent public static func atan2(y: Swift.Double, x: Swift.Double) -> Swift.Double {
    libm_atan2(y, x)
  }
  @_transparent public static func logGamma(_ x: Swift.Double) -> Swift.Double {
    var dontCare: Int32 = 0
    return libm_lgamma(x, &dontCare)
  }
  @_transparent public static func _relaxedAdd(_ a: Swift.Double, _ b: Swift.Double) -> Swift.Double {
    _numerics_relaxed_add(a, b)
  }
  @_transparent public static func _relaxedMul(_ a: Swift.Double, _ b: Swift.Double) -> Swift.Double {
    _numerics_relaxed_mul(a, b)
  }
}
public protocol ElementaryFunctions : Swift.AdditiveArithmetic {
  static func exp(_ x: Self) -> Self
  static func expMinusOne(_ x: Self) -> Self
  static func cosh(_ x: Self) -> Self
  static func sinh(_ x: Self) -> Self
  static func tanh(_ x: Self) -> Self
  static func cos(_ x: Self) -> Self
  static func sin(_ x: Self) -> Self
  static func tan(_ x: Self) -> Self
  static func log(_ x: Self) -> Self
  static func log(onePlus x: Self) -> Self
  static func acosh(_ x: Self) -> Self
  static func asinh(_ x: Self) -> Self
  static func atanh(_ x: Self) -> Self
  static func acos(_ x: Self) -> Self
  static func asin(_ x: Self) -> Self
  static func atan(_ x: Self) -> Self
  static func pow(_ x: Self, _ y: Self) -> Self
  static func pow(_ x: Self, _ n: Swift.Int) -> Self
  static func sqrt(_ x: Self) -> Self
  static func root(_ x: Self, _ n: Swift.Int) -> Self
}
extension Swift.Float : RealModule.Real {
  @_transparent public static func cos(_ x: Swift.Float) -> Swift.Float {
    libm_cosf(x)
  }
  @_transparent public static func sin(_ x: Swift.Float) -> Swift.Float {
    libm_sinf(x)
  }
  @_transparent public static func tan(_ x: Swift.Float) -> Swift.Float {
    libm_tanf(x)
  }
  @_transparent public static func acos(_ x: Swift.Float) -> Swift.Float {
    libm_acosf(x)
  }
  @_transparent public static func asin(_ x: Swift.Float) -> Swift.Float {
    libm_asinf(x)
  }
  @_transparent public static func atan(_ x: Swift.Float) -> Swift.Float {
    libm_atanf(x)
  }
  @_transparent public static func cosh(_ x: Swift.Float) -> Swift.Float {
    libm_coshf(x)
  }
  @_transparent public static func sinh(_ x: Swift.Float) -> Swift.Float {
    libm_sinhf(x)
  }
  @_transparent public static func tanh(_ x: Swift.Float) -> Swift.Float {
    libm_tanhf(x)
  }
  @_transparent public static func acosh(_ x: Swift.Float) -> Swift.Float {
    libm_acoshf(x)
  }
  @_transparent public static func asinh(_ x: Swift.Float) -> Swift.Float {
    libm_asinhf(x)
  }
  @_transparent public static func atanh(_ x: Swift.Float) -> Swift.Float {
    libm_atanhf(x)
  }
  @_transparent public static func exp(_ x: Swift.Float) -> Swift.Float {
    libm_expf(x)
  }
  @_transparent public static func expMinusOne(_ x: Swift.Float) -> Swift.Float {
    libm_expm1f(x)
  }
  @_transparent public static func log(_ x: Swift.Float) -> Swift.Float {
    libm_logf(x)
  }
  @_transparent public static func log(onePlus x: Swift.Float) -> Swift.Float {
    libm_log1pf(x)
  }
  @_transparent public static func erf(_ x: Swift.Float) -> Swift.Float {
    libm_erff(x)
  }
  @_transparent public static func erfc(_ x: Swift.Float) -> Swift.Float {
    libm_erfcf(x)
  }
  @_transparent public static func exp2(_ x: Swift.Float) -> Swift.Float {
    libm_exp2f(x)
  }
  @_transparent public static func exp10(_ x: Swift.Float) -> Swift.Float {
    libm_exp10f(x)
  }
  @_transparent public static func hypot(_ x: Swift.Float, _ y: Swift.Float) -> Swift.Float {
    libm_hypotf(x, y)
  }
  @_transparent public static func gamma(_ x: Swift.Float) -> Swift.Float {
    libm_tgammaf(x)
  }
  @_transparent public static func log2(_ x: Swift.Float) -> Swift.Float {
    libm_log2f(x)
  }
  @_transparent public static func log10(_ x: Swift.Float) -> Swift.Float {
    libm_log10f(x)
  }
  @_transparent public static func pow(_ x: Swift.Float, _ y: Swift.Float) -> Swift.Float {
    guard x >= 0 else { return .nan }
    if x == 0 && y == 0 { return .nan }
    return libm_powf(x, y)
  }
  @_transparent public static func pow(_ x: Swift.Float, _ n: Swift.Int) -> Swift.Float {
     
    if let y = Float(exactly: n) {
      return libm_powf(x, y)
    }
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
    let mask = Int(truncatingIfNeeded: 0xffffff)
    let round = n < 0 ? mask : 0
    let high = (n &+ round) & ~mask
    let low = n &- high
    return libm_powf(x, Float(low)) * libm_powf(x, Float(high))
  }
  @_transparent public static func root(_ x: Swift.Float, _ n: Swift.Int) -> Swift.Float {
    guard x >= 0 || n % 2 != 0 else { return .nan }
     
     
    if n == 3 { return libm_cbrtf(x) }
     
     
    return Float(signOf: x, magnitudeOf: libm_powf(x.magnitude, 1/Float(n)))
  }
  @_transparent public static func atan2(y: Swift.Float, x: Swift.Float) -> Swift.Float {
    libm_atan2f(y, x)
  }
  @_transparent public static func logGamma(_ x: Swift.Float) -> Swift.Float {
    var dontCare: Int32 = 0
    return libm_lgammaf(x, &dontCare)
  }
  @_transparent public static func _relaxedAdd(_ a: Swift.Float, _ b: Swift.Float) -> Swift.Float {
    _numerics_relaxed_addf(a, b)
  }
  @_transparent public static func _relaxedMul(_ a: Swift.Float, _ b: Swift.Float) -> Swift.Float {
    _numerics_relaxed_mulf(a, b)
  }
}
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
extension Swift.Float16 : RealModule.Real {
  @_transparent public static func cos(_ x: Swift.Float16) -> Swift.Float16 {
    Float16(.cos(Float(x)))
  }
  @_transparent public static func sin(_ x: Swift.Float16) -> Swift.Float16 {
    Float16(.sin(Float(x)))
  }
  @_transparent public static func tan(_ x: Swift.Float16) -> Swift.Float16 {
    Float16(.tan(Float(x)))
  }
  @_transparent public static func acos(_ x: Swift.Float16) -> Swift.Float16 {
    Float16(.acos(Float(x)))
  }
  @_transparent public static func asin(_ x: Swift.Float16) -> Swift.Float16 {
    Float16(.asin(Float(x)))
  }
  @_transparent public static func atan(_ x: Swift.Float16) -> Swift.Float16 {
    Float16(.atan(Float(x)))
  }
  @_transparent public static func cosh(_ x: Swift.Float16) -> Swift.Float16 {
    Float16(.cosh(Float(x)))
  }
  @_transparent public static func sinh(_ x: Swift.Float16) -> Swift.Float16 {
    Float16(.sinh(Float(x)))
  }
  @_transparent public static func tanh(_ x: Swift.Float16) -> Swift.Float16 {
    Float16(.tanh(Float(x)))
  }
  @_transparent public static func acosh(_ x: Swift.Float16) -> Swift.Float16 {
    Float16(.acosh(Float(x)))
  }
  @_transparent public static func asinh(_ x: Swift.Float16) -> Swift.Float16 {
    Float16(.asinh(Float(x)))
  }
  @_transparent public static func atanh(_ x: Swift.Float16) -> Swift.Float16 {
    Float16(.atanh(Float(x)))
  }
  @_transparent public static func exp(_ x: Swift.Float16) -> Swift.Float16 {
    Float16(.exp(Float(x)))
  }
  @_transparent public static func expMinusOne(_ x: Swift.Float16) -> Swift.Float16 {
    Float16(.expMinusOne(Float(x)))
  }
  @_transparent public static func log(_ x: Swift.Float16) -> Swift.Float16 {
    Float16(.log(Float(x)))
  }
  @_transparent public static func log(onePlus x: Swift.Float16) -> Swift.Float16 {
    Float16(.log(onePlus: Float(x)))
  }
  @_transparent public static func erf(_ x: Swift.Float16) -> Swift.Float16 {
    Float16(.erf(Float(x)))
  }
  @_transparent public static func erfc(_ x: Swift.Float16) -> Swift.Float16 {
    Float16(.erfc(Float(x)))
  }
  @_transparent public static func exp2(_ x: Swift.Float16) -> Swift.Float16 {
    Float16(.exp2(Float(x)))
  }
  @_transparent public static func exp10(_ x: Swift.Float16) -> Swift.Float16 {
    Float16(.exp10(Float(x)))
  }
  @_transparent public static func hypot(_ x: Swift.Float16, _ y: Swift.Float16) -> Swift.Float16 {
    if x.isInfinite || y.isInfinite { return .infinity }
    let xf = Float(x)
    let yf = Float(y)
    return Float16(.sqrt(xf*xf + yf*yf))
  }
  @_transparent public static func gamma(_ x: Swift.Float16) -> Swift.Float16 {
    Float16(.gamma(Float(x)))
  }
  @_transparent public static func log2(_ x: Swift.Float16) -> Swift.Float16 {
    Float16(.log2(Float(x)))
  }
  @_transparent public static func log10(_ x: Swift.Float16) -> Swift.Float16 {
    Float16(.log10(Float(x)))
  }
  @_transparent public static func pow(_ x: Swift.Float16, _ y: Swift.Float16) -> Swift.Float16 {
    Float16(.pow(Float(x), Float(y)))
  }
  @_transparent public static func pow(_ x: Swift.Float16, _ n: Swift.Int) -> Swift.Float16 {
     
     
     
     
     
     
    let clamped = min(max(n, -0x10000), 0x10000) | (n & 1)
    return Float16(libm_powf(Float(x), Float(clamped)))
  }
  @_transparent public static func root(_ x: Swift.Float16, _ n: Swift.Int) -> Swift.Float16 {
    Float16(.root(Float(x), n))
  }
  @_transparent public static func atan2(y: Swift.Float16, x: Swift.Float16) -> Swift.Float16 {
    Float16(.atan2(y: Float(y), x: Float(x)))
  }
  @_transparent public static func logGamma(_ x: Swift.Float16) -> Swift.Float16 {
    Float16(.logGamma(Float(x)))
  }
  @_transparent public static func _relaxedAdd(_ a: Swift.Float16, _ b: Swift.Float16) -> Swift.Float16 {
    _numerics_relaxed_addf16(a, b)
  }
  @_transparent public static func _relaxedMul(_ a: Swift.Float16, _ b: Swift.Float16) -> Swift.Float16 {
    _numerics_relaxed_mulf16(a, b)
  }
}
public protocol Real : RealModule.AlgebraicField, RealModule.RealFunctions, Swift.FloatingPoint {
}
extension RealModule.Real {
  @_transparent public static func exp10(_ x: Self) -> Self {
    pow(10, x)
  }
  @_transparent public static func cosMinusOne(_ x: Self) -> Self {
    let sinxOver2 = sin(x/2)
    return -2*sinxOver2*sinxOver2
  }
  public static func signGamma(_ x: Self) -> Swift.FloatingPointSign
  @_transparent public static func _mulAdd(_ a: Self, _ b: Self, _ c: Self) -> Self {
    a*b + c
  }
  @_transparent public static func sqrt(_ x: Self) -> Self {
    x.squareRoot()
  }
  #if compiler(>=5.3) && $NonescapableTypes
  @inlinable public var reciprocal: Self? {
    get {
    let recip = 1/self
    if recip.isNormal || isZero || !isFinite {
      return recip
    }
    return nil
  }
  }
  #endif
}
public protocol RealFunctions : RealModule.ElementaryFunctions {
  static func atan2(y: Self, x: Self) -> Self
  static func erf(_ x: Self) -> Self
  static func erfc(_ x: Self) -> Self
  static func exp2(_ x: Self) -> Self
  static func exp10(_ x: Self) -> Self
  static func hypot(_ x: Self, _ y: Self) -> Self
  static func gamma(_ x: Self) -> Self
  static func log2(_ x: Self) -> Self
  static func log10(_ x: Self) -> Self
  static func logGamma(_ x: Self) -> Self
  static func signGamma(_ x: Self) -> Swift.FloatingPointSign
}
public enum Relaxed {
}
extension RealModule.Relaxed {
  @_transparent public static func sum<T>(_ a: T, _ b: T) -> T where T : RealModule.AlgebraicField {
    T._relaxedAdd(a, b)
  }
  @_transparent public static func product<T>(_ a: T, _ b: T) -> T where T : RealModule.AlgebraicField {
    T._relaxedMul(a, b)
  }
}
extension RealModule.Relaxed {
  @_transparent public static func multiplyAdd<T>(_ a: T, _ b: T, _ c: T) -> T where T : RealModule.AlgebraicField {
    T._relaxedAdd(c, T._relaxedMul(a, b))
  }
}
